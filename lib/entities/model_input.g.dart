// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'model_input.dart';

// **************************************************************************
// CopyWithGenerator
// **************************************************************************

abstract class _$ModelInputCWProxy {
  ModelInput timestamp(int? timestamp);

  ModelInput accelerometerX(double accelerometerX);

  ModelInput linearAccelerometerX(double linearAccelerometerX);

  ModelInput magnetometerX(double magnetometerX);

  ModelInput gravityX(double gravityX);

  ModelInput eulerX(double eulerX);

  ModelInput eulerZ(double eulerZ);

  ModelInput quaternionX(double quaternionX);

  ModelInput quaternionZ(double quaternionZ);

  ModelInput inverseQuaternionX(double inverseQuaternionX);

  ModelInput inverseQuaternionZ(double inverseQuaternionZ);

  ModelInput relativeOrientationZ(double relativeOrientationZ);

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `ModelInput(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// ModelInput(...).copyWith(id: 12, name: "My name")
  /// ````
  ModelInput call({
    int? timestamp,
    double? accelerometerX,
    double? linearAccelerometerX,
    double? magnetometerX,
    double? gravityX,
    double? eulerX,
    double? eulerZ,
    double? quaternionX,
    double? quaternionZ,
    double? inverseQuaternionX,
    double? inverseQuaternionZ,
    double? relativeOrientationZ,
  });
}

/// Proxy class for `copyWith` functionality. This is a callable class and can be used as follows: `instanceOfModelInput.copyWith(...)`. Additionally contains functions for specific fields e.g. `instanceOfModelInput.copyWith.fieldName(...)`
class _$ModelInputCWProxyImpl implements _$ModelInputCWProxy {
  const _$ModelInputCWProxyImpl(this._value);

  final ModelInput _value;

  @override
  ModelInput timestamp(int? timestamp) => this(timestamp: timestamp);

  @override
  ModelInput accelerometerX(double accelerometerX) =>
      this(accelerometerX: accelerometerX);

  @override
  ModelInput linearAccelerometerX(double linearAccelerometerX) =>
      this(linearAccelerometerX: linearAccelerometerX);

  @override
  ModelInput magnetometerX(double magnetometerX) =>
      this(magnetometerX: magnetometerX);

  @override
  ModelInput gravityX(double gravityX) => this(gravityX: gravityX);

  @override
  ModelInput eulerX(double eulerX) => this(eulerX: eulerX);

  @override
  ModelInput eulerZ(double eulerZ) => this(eulerZ: eulerZ);

  @override
  ModelInput quaternionX(double quaternionX) => this(quaternionX: quaternionX);

  @override
  ModelInput quaternionZ(double quaternionZ) => this(quaternionZ: quaternionZ);

  @override
  ModelInput inverseQuaternionX(double inverseQuaternionX) =>
      this(inverseQuaternionX: inverseQuaternionX);

  @override
  ModelInput inverseQuaternionZ(double inverseQuaternionZ) =>
      this(inverseQuaternionZ: inverseQuaternionZ);

  @override
  ModelInput relativeOrientationZ(double relativeOrientationZ) =>
      this(relativeOrientationZ: relativeOrientationZ);

  @override

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `ModelInput(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// ModelInput(...).copyWith(id: 12, name: "My name")
  /// ````
  ModelInput call({
    Object? timestamp = const $CopyWithPlaceholder(),
    Object? accelerometerX = const $CopyWithPlaceholder(),
    Object? linearAccelerometerX = const $CopyWithPlaceholder(),
    Object? magnetometerX = const $CopyWithPlaceholder(),
    Object? gravityX = const $CopyWithPlaceholder(),
    Object? eulerX = const $CopyWithPlaceholder(),
    Object? eulerZ = const $CopyWithPlaceholder(),
    Object? quaternionX = const $CopyWithPlaceholder(),
    Object? quaternionZ = const $CopyWithPlaceholder(),
    Object? inverseQuaternionX = const $CopyWithPlaceholder(),
    Object? inverseQuaternionZ = const $CopyWithPlaceholder(),
    Object? relativeOrientationZ = const $CopyWithPlaceholder(),
  }) {
    return ModelInput(
      timestamp: timestamp == const $CopyWithPlaceholder()
          ? _value.timestamp
          // ignore: cast_nullable_to_non_nullable
          : timestamp as int?,
      accelerometerX: accelerometerX == const $CopyWithPlaceholder() ||
              accelerometerX == null
          ? _value.accelerometerX
          // ignore: cast_nullable_to_non_nullable
          : accelerometerX as double,
      linearAccelerometerX:
          linearAccelerometerX == const $CopyWithPlaceholder() ||
                  linearAccelerometerX == null
              ? _value.linearAccelerometerX
              // ignore: cast_nullable_to_non_nullable
              : linearAccelerometerX as double,
      magnetometerX:
          magnetometerX == const $CopyWithPlaceholder() || magnetometerX == null
              ? _value.magnetometerX
              // ignore: cast_nullable_to_non_nullable
              : magnetometerX as double,
      gravityX: gravityX == const $CopyWithPlaceholder() || gravityX == null
          ? _value.gravityX
          // ignore: cast_nullable_to_non_nullable
          : gravityX as double,
      eulerX: eulerX == const $CopyWithPlaceholder() || eulerX == null
          ? _value.eulerX
          // ignore: cast_nullable_to_non_nullable
          : eulerX as double,
      eulerZ: eulerZ == const $CopyWithPlaceholder() || eulerZ == null
          ? _value.eulerZ
          // ignore: cast_nullable_to_non_nullable
          : eulerZ as double,
      quaternionX:
          quaternionX == const $CopyWithPlaceholder() || quaternionX == null
              ? _value.quaternionX
              // ignore: cast_nullable_to_non_nullable
              : quaternionX as double,
      quaternionZ:
          quaternionZ == const $CopyWithPlaceholder() || quaternionZ == null
              ? _value.quaternionZ
              // ignore: cast_nullable_to_non_nullable
              : quaternionZ as double,
      inverseQuaternionX: inverseQuaternionX == const $CopyWithPlaceholder() ||
              inverseQuaternionX == null
          ? _value.inverseQuaternionX
          // ignore: cast_nullable_to_non_nullable
          : inverseQuaternionX as double,
      inverseQuaternionZ: inverseQuaternionZ == const $CopyWithPlaceholder() ||
              inverseQuaternionZ == null
          ? _value.inverseQuaternionZ
          // ignore: cast_nullable_to_non_nullable
          : inverseQuaternionZ as double,
      relativeOrientationZ:
          relativeOrientationZ == const $CopyWithPlaceholder() ||
                  relativeOrientationZ == null
              ? _value.relativeOrientationZ
              // ignore: cast_nullable_to_non_nullable
              : relativeOrientationZ as double,
    );
  }
}

extension $ModelInputCopyWith on ModelInput {
  /// Returns a callable class that can be used as follows: `instanceOfModelInput.copyWith(...)` or like so:`instanceOfModelInput.copyWith.fieldName(...)`.
  // ignore: library_private_types_in_public_api
  _$ModelInputCWProxy get copyWith => _$ModelInputCWProxyImpl(this);
}

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class ModelInputAdapter extends TypeAdapter<ModelInput> {
  @override
  final int typeId = 2;

  @override
  ModelInput read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return ModelInput(
      timestamp: fields[0] as int?,
      accelerometerX: fields[1] as double,
      linearAccelerometerX: fields[2] as double,
      magnetometerX: fields[11] as double,
      gravityX: fields[3] as double,
      eulerX: fields[4] as double,
      eulerZ: fields[5] as double,
      quaternionX: fields[6] as double,
      quaternionZ: fields[7] as double,
      inverseQuaternionX: fields[8] as double,
      inverseQuaternionZ: fields[9] as double,
      relativeOrientationZ: fields[10] as double,
    );
  }

  @override
  void write(BinaryWriter writer, ModelInput obj) {
    writer
      ..writeByte(12)
      ..writeByte(0)
      ..write(obj.timestamp)
      ..writeByte(1)
      ..write(obj.accelerometerX)
      ..writeByte(2)
      ..write(obj.linearAccelerometerX)
      ..writeByte(3)
      ..write(obj.gravityX)
      ..writeByte(4)
      ..write(obj.eulerX)
      ..writeByte(5)
      ..write(obj.eulerZ)
      ..writeByte(6)
      ..write(obj.quaternionX)
      ..writeByte(7)
      ..write(obj.quaternionZ)
      ..writeByte(8)
      ..write(obj.inverseQuaternionX)
      ..writeByte(9)
      ..write(obj.inverseQuaternionZ)
      ..writeByte(10)
      ..write(obj.relativeOrientationZ)
      ..writeByte(11)
      ..write(obj.magnetometerX);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ModelInputAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

ModelInput _$ModelInputFromJson(Map<String, dynamic> json) => ModelInput(
      timestamp: json['timestamp'] as int?,
      accelerometerX: (json['accelerometer_x'] as num).toDouble(),
      linearAccelerometerX: (json['linear_accelerometer_x'] as num).toDouble(),
      magnetometerX: (json['magnetometer_x'] as num).toDouble(),
      gravityX: (json['gravity_x'] as num).toDouble(),
      eulerX: (json['euler_x'] as num).toDouble(),
      eulerZ: (json['euler_z'] as num).toDouble(),
      quaternionX: (json['quaternion_x'] as num).toDouble(),
      quaternionZ: (json['quaternion_z'] as num).toDouble(),
      inverseQuaternionX: (json['inverse_quaternion_x'] as num).toDouble(),
      inverseQuaternionZ: (json['inverse_quaternion_z'] as num).toDouble(),
      relativeOrientationZ: (json['relative_orientation_z'] as num).toDouble(),
    );

Map<String, dynamic> _$ModelInputToJson(ModelInput instance) =>
    <String, dynamic>{
      'timestamp': instance.timestamp,
      'accelerometer_x': instance.accelerometerX,
      'linear_accelerometer_x': instance.linearAccelerometerX,
      'gravity_x': instance.gravityX,
      'euler_x': instance.eulerX,
      'euler_z': instance.eulerZ,
      'quaternion_x': instance.quaternionX,
      'quaternion_z': instance.quaternionZ,
      'inverse_quaternion_x': instance.inverseQuaternionX,
      'inverse_quaternion_z': instance.inverseQuaternionZ,
      'relative_orientation_z': instance.relativeOrientationZ,
      'magnetometer_x': instance.magnetometerX,
    };
